
.. Copyright (C) 2007,2008,2009,2010,2011 Olly Betts
.. Copyright (C) 2011 Nikita Smetanin

==========================
Xapian Spelling Correction
==========================

.. contents:: Table of contents

Introduction
============

Xapian provides functionality which can suggest corrections for misspelled
words in queries, or in other situations where it might be useful.  The
suggestions can be generated dynamically from the data that has been indexed,
so the correction facility isn't tied to particular languages, and can suggest
proper nouns or specialist technical terms.

Indexing
========

The spelling dictionary can be built with words from indexed text, or by adding
words from a static word list, or a combination of the two.

Static spelling data
--------------------

If ``db`` is a Xapian::WritableDatabase, you can add to the spelling dictionary
using::

    db.add_spelling(word, frequency_inc);

The ``frequency_inc`` parameter is optional, and defaults to 1.

And the corresponding way to remove from the spelling dictionary is::

    db.remove_spelling(word, frequency_dec);

The ``frequency_dec`` parameter is optional and defaults to 1.  If you try to
decrement the frequency of a word by more than its current value, it's just
removed.

To store pairs and triples of words you should use::

    db.add_spelling(first_word, second_word, frequency_inc);
    db.add_spelling(first_word, second_word, third_word, frequency_inc);

And respectively to remove you may use::

    db.remove_spelling(first_word, second_word, frequency_dec);
    db.remove_spelling(first_word, second_word, third_word, frequency_dec);

Also, each of these methods above can obtain prefix as the last argument.

Dynamic spelling data
---------------------

``Xapian::TermGenerator`` can be configured to automatically add words from
indexed documents to the spelling dictionary::

    Xapian::TermGenerator indexer;
    indexer.set_database(db);
    indexer.set_flags(indexer.FLAG_SPELLING);

Note that you must call the ``set_database()`` method as well as setting
``FLAG_SPELLING`` so that Xapian knows where to add the spelling dictionary
entries.

If a document is removed or replaced, any spelling dictionary entries that
were added when it was originally indexed won't be automatically removed.
This might seem like a flaw, but in practice it rarely causes problems, and
spellings in documents which were in the database, or in older versions of
documents, are still interesting.  You can think of this as using the history
of the document collection as a source of spelling data.

If you really want these entries removed, you can run through the termlist of
each document you are about to remove or replace (if you indexed terms
unstemmed) and call ``remove_spelling()`` for each word.

Searching
=========

QueryParser Integration
-----------------------

If FLAG_SPELLING_CORRECTION is passed to QueryParser::parse_query() and
QueryParser::set_database() has been called, the QueryParser will look for
corrections for words in the query.  In Xapian 1.2.2 and earlier, it only
did this for terms which aren't found in the database.

If a correction is found, then a modified version of the query string will be
generated which can be obtained by calling
QueryParser::get_corrected_query_string().  However, the original query string
will still be parsed, since you'll often want to ask the user "Did you mean:
[...] ?" - if you want to automatically use the corrected form, just call
QueryParser::parse_query() on it.

If FLAG_AUTO_SPELLING_CORRECTION is enabled, query will be formed using suggested
corrections. FLAG_AUTO_MULTIWORD_SPELLING_CORRECTION enables word sequence
corrections to be integrated into a query.

Omega
=====

As of Omega 1.1.1, omindex and scriptindex support indexing spelling correction
data and omega supports suggesting corrected spellings at search time.  See the
`Omega documentation <http://xapian.org/docs/omega/>`_ for more details.

Algorithm
=========

Default N-Gram
--------------

A list of candidate words is generated by matching trigrams (groups of 3
adjacent characters) in the candidates against those in the misspelled
word.  As well as groups of adjacent characters, "starts" and "ends"
are generated with the first two and last two characters respectively
(e.g. "FISH" generates: "<start>FI", "FIS", "ISH", and "SH<end>").

This technique alone would missing many single-edit errors in two and three
character words, so we handle these specially as follows:

For a three character word (e.g. "ABC"), we generate trigrams for the two
transposed forms too ("BAC" and "ACB"), in addition to "<start>AB", "ABC",
and "BC<end>".

For a two character word (e.g. "AB"), we generate the special start and end
trigrams for the reversed form (i.e. "BA"), so the trigrams are "<start>AB",
"AB<end>", "<start>BA", and "BA<end>".

And for two, three, and four character words, we generate "bookend" bigrams
consisting of the prefix 'B' followed by the first and last letters.  This
allows us to handle transposition of the middle two characters of a four
letter word, substitution or deletion of the middle character of a three
letter word, or insertion in the middle of a two letter word.

Note that we don't attempt to suggest corrections for single character words
at all, since the suggestions are unlikely to be of good quality (we'd always
suggest the same correction for a given database, probably "a" for English).
We also don't currently attempt to suggest substitution corrections for two
character words, though this would perhaps be useful in some cases.

Those candidates with the better trigram matches are compared to the misspelled
word by calculating the "edit distance" - that's the smallest number of
operations required to turn one word into another.  The allowed operations
are: insert a character; delete a character; change a character to another;
transpose two adjacent characters.  The candidate with the smallest edit
distance is found, and if more than one word has the smallest edit distance,
that which occurs the most times is chosen.  If there's a tie of this too,
it's essentially arbitrary which is chosen.

If the word passed in is in the spelling dictionary, then a candidate will
still be returned if one is found with the same or greater frequency.

The maximum edit distance to consider can be specified as an optional parameter
to Xapian::Database::get_spelling_suggestion().  If not specified, the default
is 2, which generally does a good job.  3 is also a reasonable choice in many
cases.  For most uses, 1 is probably too low, and 4 or more probably too high.

Unicode Support (Only for default N-Gram)
-----------------------------------------

Trigrams are generated at the byte level, but the edit distance calculation
currently works with Unicode characters, so get_spelling_suggestion() should
suggest suitable spelling corrections respecting the specified (or default)
edit distance threshold.

Optimized N-Gram
----------------

This method has one significant N-Gram method optimization, which makes it
two times faster without increase of memory usage.

The main idea of this optimization is if the result is limited with edit
distance (error count, k), than the same n-grams in indexed and queried
words can't differ in position in the word more than k.
Then, we should store n-grams separately by its position in the indexing
word. During the query, we should check only these n-grams, which position
doesn't differ more than k from position in queried word.

FastSS algorithm
----------------

This algorithm is based on the reduction from fuzzy string search to exact
string search. This reduction is performed by letter deletions (skips) in
indexing and quering words. Letter skips at the same positions in both
indexed and queried words allow one substitution. Letter skip in indexed
word allows one deletion. Letter skip in queried word allows one insertion.
Letter skips at the adjacent positions allows one transposition.

This algorithm has a very high speed - up to 10 times faster than original
n-gram. But it requires significantly more memory to store index.

Unicode Support
---------------

Spelling suggestions subsystem has full unicode support.
All operations are performed at the unicode character level.

Word sequence suggestions algorithm
===================================

Resulting suggestion sequence is chosen among different variants with
maximum total relative freq - the sum of relative freqs of all word pairs.

Word corrections
----------------

Word corrections module provide most optimal result by iterating over all
possible combinations of words, lists of its possible corrections,
its transliterations and words with changed keyboard layouts.

It also supports gapping - counting total frequency with some word skipped
to provide more smooth result.

Word splits and joins
---------------------

Word splits an joins module search for most optimal result by trying to
stick some words together and break a word (or some sticked words) into parts
at the same time. Unknown parts of words are checked for possible corrections.

Multiple suggestions algorithm
==============================

This algorithm provide several spelling suggestions to give freedom to
choose spelling results.

To provide a variety of resulting sequences, these sequences is ordered by
not only total frequency, but also by "unlikeness" distance.

Unlikeness distance is the ratio of count of mismatched words to count of all
words in sequences.

The unlikeness distance and frequency are higher, the sequence more preferable.

Resulting unlikeness distance is counted as an average to all previous
sequences.

The first sequence in the result is always the most frequent one.
The second sequence is the most frequent and with the highest unlikeness
distance to the first sequence.
The third sequence is the most frequent too and with the highest unlikeness
distance to the both first and second sequences. And so on.

Transliteration and Keyboard layouts
====================================

Transliteration module provides a list of transliterations (from the native
to the latin alphabet) and sometimes reverse transliterations (from the
latin alphabet back to the native) for the given word.

Each word may has a lot of variants because each letter of group of letters
involved in transliteration may has alternative mappings.

Keyboard layouts module provides different layouts to allow word's convertion
between them, which is helpful in "keyboard layout error", when the word was
typed using a wrong layout.

It provides two-way convertion - from the native to the english layout, and
from the english layout to the native one. Also, it provides distances between
keys on keyboard for using in spelling correction module.

Extended edit distance
======================

Extedned edit distance provide more precise and logically implied
Damerau-Levenshtein distance. It defines custom variable costs for 
insertions / deletions, substitutions and transpositions. Each cost is
calculated using base value and index cost (relative letter position in a word).

Extended edit distance also supports keyboard layouts and may adjust the
substitution cost taking into account distance between keys on keyboard.

Current Limitations
===================

Exactness
---------

Because Xapian only tests the edit distance for terms which match
well (or at all!) on n-grams, it may not always suggest the same answer that
would be found if all possible words were checked using the edit distance
algorithm.  However, the best answer will usually be found, and an exhaustive
search would be prohibitively expensive for many uses.

FastSS algorithm produce significantly more comprehensive results, which has
maximum possible mistakes coverage. In addition, its quality is independent 
of a word's length.

Backend Support
---------------

Currently spelling correction is supported for chert, and brass
databases.  It works with a single database or multiple databases (use
Database::add_database() as usual).  We've no plans to support it for the
InMemory backend, but we do intend to support it for
the remote backend in the future. Optimized N-Gram and FastSS methods are 
available only for brass backend.

Prefixed Terms
--------------

Prefixed terms is fully supported by the brass backend (for all methods except
default N-Gram). To enable or disable spelling for the certain prefixes, use
enable_spelling(...) and disable_spelling(...) methods.

Prefixes may be united in groups to share spelling data between prefixes within
such a group or unprefixed data.

QueryParser changed word locations
----------------------------------

The QueryParser doesn't currently report the locations of changed words in
the query string, so it's a bit fiddly to mark up the altered words specially
in HTML output, for example.

References
==========

The algorithm used to calculate the edit distance is based on that described in
the paper "An extension of Ukkonen's enhanced dynamic programming ASM
algorithm" by Hal Berghel, University of Arkansas, and David Roach, Acxiom
Corporation.  It's available online at:
http://berghel.net/publications/asm/asm.php
